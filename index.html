
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>a4</title>
    <meta name="description" content="Assignment 4">
    <link id="favicon" rel="icon" href="https://glitch.com/edit/favicon-app.ico" type="image/x-icon">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="./style.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet">
    <script src="js/three.js"></script>
    <script src="js/physi.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script type="text/javascript" src="https://raw.githubusercontent.com/dataarts/dat.gui/master/build/dat.gui.js"></script>
  </head>
  <body>
     <script>
       let count = 0
       let score = 0
      'use strict';
      Physijs.scripts.worker = 'js/physijs_worker.js';
      Physijs.scripts.ammo = 'ammo.js';
      let initScene, render, renderer, scene, camera, box, ground, ground_material, friction, controls;
      var xPos = 0
      var yPos = 0
      initScene = function() {
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.getElementById( 'viewport' ).appendChild( renderer.domElement );

        scene = new Physijs.Scene;
        camera = new THREE.PerspectiveCamera(
          35,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );
        camera.position.set( 300, 100, 60 );
        camera.lookAt( scene.position );
        //controls = new THREE.OrbitControls( camera , renderer.domElement);
        scene.add( camera );
        
        var loader = new THREE.TextureLoader();
          loader.load('https://cdn.glitch.com/c3c1ab32-34b4-400c-9040-faa6873ac320%2F8bb0cedfaea9e07b8c3aa6f8c41684bc.jpg?v=1569202443143', function ( texture ) {
              ground_material = Physijs.createMaterial(
                  new THREE.MeshBasicMaterial({map: texture}) ,.8, .9), // low restitution
              // Ground
              ground = new Physijs.BoxMesh(new THREE.BoxGeometry(150, 30, 150),ground_material,1 // mass
              );
              ground.receiveShadow = true;
             ground.__dirtyRotation = true;

              var constraint = new Physijs.PointConstraint(
                  ground,
                  new THREE.Vector3( 0, 0, 0 ) 
              );
            scene.add( ground );
      
          scene.addConstraint( constraint );
          });

        // Box
         let ball_material = Physijs.createMaterial(
            new THREE.MeshBasicMaterial( { color: 0xFFFFFF } ) ,.9, .9), // low restitution
        // Ground
        box = new Physijs.BoxMesh (
          new THREE.BoxGeometry(10,10,10),
          ball_material, 1);
        box.addEventListener( 'collision', function( objCollidedWith, linearVelOfCollision, angularVelOfCollision ) {
          score++
           document.getElementById('text').innerHTML = score
           on()
           await sleep(100)
           off()
        });
        requestAnimationFrame( render );
        box.position.z = 10;
        box.position.x = 0;
        box.position.y = 50;
        box.rotation.x = 10;
        box.__dirtyPosition = true;
        document.addEventListener("keydown", onDocumentKeyDown, false); 
       
        
        document.getElementById('viewport').ondrag = getCurrPos
        document.getElementById('viewport').ondragstart = drag
        
        function sleep(ms) {
          return new Promise(resolve => setTimeout(resolve, ms))
        }

        function getCurrPos(event){
           let img = new Image();
           event.dataTransfer.setDragImage(img, 0, 0);
           xPos = event.clientX
           yPos = event.clientY
          // document.getElementById('title').innerHTML = xPos
           ground.__dirtyRotation = true;
           ground.rotation.set(xPos/200, 0, yPos /100)
          
        }
        
        function on() {
          document.getElementById("overlay").style.display = "block";
        }

        function off() {
          document.getElementById("overlay").style.display = "none";
        }
        
        function drag(event){
          let img = new Image();
          event.dataTransfer.setDragImage(img, 0, 0);
         // document.getElementById('title').innerHTML = "drag"
        }
        
        //document.addEventListener()
        
        //document.addEventListener("keyup", onDocumentKeyUp, false); 
        /*
        function onDocumentKeyDown(event) {
              let keyCode = event.which;
              if (keyCode == 87) {
                  box.applyCentralImpulse(new THREE.Vector3(0,0,-5));
              } else if (keyCode == 83) {
                   box.applyCentralImpulse(new THREE.Vector3(0,0,5));
              } else if (keyCode == 65) {
                   box.applyCentralImpulse(new THREE.Vector3(-5,0,0));
              } else if (keyCode == 68) {
                  box.applyCentralImpulse(new THREE.Vector3(5,0,0));
              }
          
            //e.preventDefault();
           //render();
          }d
          */
         let vel1 = .1
          let vel2 = .1
        function onDocumentKeyDown(event) {
              let keyCode = event.which;
              if (keyCode == 87) {
                   ground.setAngularVelocity(new THREE.Vector3(vel1, 0, 0));
                   vel1+= .1
                  count++
                 
              } else if (keyCode == 83) {
                  ground.setAngularVelocity(new THREE.Vector3(vel1, 0, 0));
                //  document.getElementById("title").style.color = "white";
                  vel1-= .1
                  count++
              } else if (keyCode == 65) {
                  ground.setAngularVelocity(new THREE.Vector3(0, -0, vel2));
                 // document.getElementById("title").style.color =  "white";
                  vel2-= .1
                  count++
              } else if (keyCode == 68) {
                   ground.setAngularVelocity(new THREE.Vector3(0, 0, vel2));
                  vel2+= .1
                  //document.getElementById("title").style.color =  "black";
                  count++
              }
        
        }
          
            //e.preventDefault();
           //render();
        
        function onDocumentKeyUp(event){
           let keyCode = event.which;
           if (keyCode == 87) {
                  ground.setLinearVelocity(new THREE.Vector3(0, 0, 0));
                  ground.setAngularVelocity(new THREE.Vector3(0, 0, 0));
              } else if (keyCode == 83) {
                   ground.setLinearVelocity(new THREE.Vector3(0, 0, 0));
                    ground.setAngularVelocity(new THREE.Vector3(0, 0, 0));
              } else if (keyCode == 65) {
                   ground.setLinearVelocity(new THREE.Vector3(0, 0, 0));
                    ground.setAngularVelocity(new THREE.Vector3(0, 0, 0));
              } else if (keyCode == 68) {
                  ground.setLinearVelocity(new THREE.Vector3(0, 0, 0));
                    ground.setAngularVelocity(new THREE.Vector3(0, 0, 0));
              }
        }
               scene.add( box );
      };
       
      render = function() {
        scene.simulate();
        renderer.render( scene, camera); // render the scen
        requestAnimationFrame( render );
        
      };   

      window.onload = function(){
        initScene();
        render();
        /*
        var gui = new dat.GUI()
        gui.add(box, 'message');
        gui.add(box, 'speed', -5, 5);
        gui.add(box, 'displayOutline');
        gui.add(box, 'explode');
        */
        
      }
    
    </script>
    <div id="overlay">
      <div id="text"></div>
    </div>
    <p id="title">
      BALANCE THE CUBE
    </p>
    	<div id="viewport" draggable = "true"></div>
  </body>
</html>
